{"version":3,"file":"store.spec.js","sourceRoot":"","sources":["../ts/store.spec.ts"],"names":[],"mappings":"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","sourcesContent":["import { isType } from 'type-plus'\nimport { createStore, ReadonlyStore, toReadonlyStore } from './store'\n\ndescribe('createStore()', () => {\n  test('get() returns initial value', () => {\n    const value = { a: 1 }\n    const store = createStore(value)\n    const a = store.get()\n    expect(a).toStrictEqual(value)\n  })\n  test('get() value from set()', () => {\n    const store = createStore({ a: 1 })\n    const value = { a: 2 }\n    store.set(value)\n    const a = store.get()\n    expect(a).toStrictEqual(value)\n  })\n\n  test('set() triggers onChange()', () => {\n    const store = createStore({ a: 1 })\n\n    let actual: unknown\n    store.onChange(v => actual = v)\n\n    const value = { a: 2 }\n    store.set(value)\n    expect(actual).toStrictEqual(value)\n  })\n\n  test('update() by modify', () => {\n    const store = createStore({ a: 1 })\n    store.update(s => { s.a = 2 })\n    const a = store.get()\n    expect(a).toEqual({ a: 2 })\n  })\n\n  test('update() by return', () => {\n    const store = createStore({ a: 1 })\n    store.update(() => ({ a: 2 }))\n    const a = store.get()\n    expect(a).toEqual({ a: 2 })\n  })\n\n  test('NaN -> NaN does not trigger onChange()', () => {\n    const store = createStore(NaN)\n    store.onChange(() => { throw 'should not reach' })\n    store.set(NaN)\n  })\n\n  test('NaN -> number works as expected', () => {\n    const store = createStore(NaN)\n    store.set(123)\n    expect(store.get()).toBe(123)\n  })\n})\n\ndescribe('toReadonly()', () => {\n  test('for scalar store', () => {\n    const s = createStore(1)\n    const r = toReadonlyStore(s)\n\n    expect(Object.keys(r)).toEqual(['get', 'onChange'])\n    isType.equal<true, ReadonlyStore<number>, typeof r>()\n  })\n  test('for record store', () => {\n    // `createStore(record({ a: 1 }))` is better\n    // but use object literal as an example because it is more common\n    const s = createStore({ a: 1 })\n    const r = toReadonlyStore(s)\n\n    expect(Object.keys(r)).toEqual(['get', 'onChange'])\n    isType.equal<true, ReadonlyStore<{ a: number }>, typeof r>()\n  })\n  test('for array store', () => {\n    const s = createStore([1, 2])\n    const r = toReadonlyStore(s)\n\n    expect(Object.keys(r)).toEqual(['get', 'onChange'])\n    isType.equal<true, ReadonlyStore<number[]>, typeof r>()\n  })\n})\n"]}